# Cedille Parser [![Build Status](https://travis-ci.org/ernius/cedilleparser.svg?branch=master)](https://travis-ci.org/ernius/cedilleparser)

Dependant typed programming language (called Cedille) parser developed in Haskell.

## Project details

Source code:
 * Lexer  [src/CedilleLexer.x](src/CedilleLexer.x)
 * Parser [src/CedilleParser.y](src/CedilleParser.y)

Some working examples tested in [test](test) project sub folder.

Haskell parser exported to Agda. Haskell AST datatype ([src/CedilleTypes.hs](src/CedilleTypes.agda)) export to Agda AST datatype ([src/cedille-types.agda](src/cedille-types.agda)), and minimal example calling the Haskell's parser from Agda ([src/test.agda](src/test.agda)).

Makefile/Cabal commands:
 * Build: `cabal build`.
 * Running tests: `cabal test` or `make tests`.
 * Running tests in debug mode: `make tests-debug`.
 * Rebuild parser info file: `make info`.
 * Running agda test: `make agda-test`.

## Must review:

* Reserved words: **import**, **module**, **as**, **let**, **in** and other several symbols.

* White spaces treatment. Avoid spaces treatment in the grammar, discarding them in the lexical phase.

* Shifting in the AST position information.

Next, are the results of the Agda's parser, and this one, for the same input. It seems to exist a ten units shiftment in the position information (perhaps the length of module statement?). There also exist a divergence of one unit in the last pos. info. of `DefTermOrType` nodes (delimited by ** markers). 

Input: `module Cnat. cNat ◂ ★ = ∀ X : ★ . (X ➔ X) ➔ X ➔ X . cZ ◂ cNat = Λ X . λ f . λ a . a . cS ◂ cNat ➔ cNat = λ n . Λ X . λ f . λ a . f (n · X f a) .`

Agda's parser:

```
File "10" ImportsStart "Cnat" ParamsNil
     (CmdsNext (DefTermOrType (DefType "23" "cNat" (Star "30") (Abs "34" All "36" "X" (Tkk (Star "40")) (TpArrow (TpParens "44" (TpArrow (TpVar "45" "X") UnerasedArrow (TpVar "49" "X")) "51") UnerasedArrow (TpArrow (TpVar "54" "X") UnerasedArrow (TpVar "58" "X"))))) **"61"**)
     (CmdsNext (DefTermOrType (DefTerm "62" "cZ" (Type (TpVar "67" "cNat")) (Lam "74" ErasedLambda "76" "X" NoClass (Lam "80" KeptLambda "82" "f" NoClass (Lam "86" KeptLambda "88" "a" NoClass (Var "92" "a"))))) **"95"**)
     (CmdsNext (DefTermOrType (DefTerm "96" "cS" (Type (TpArrow (TpVar "101" "cNat") UnerasedArrow (TpVar "108" "cNat"))) (Lam "115" KeptLambda "117" "n" NoClass (Lam "121" ErasedLambda "123" "X" NoClass (Lam "127" KeptLambda "129" "f" NoClass (Lam "133" KeptLambda "135" "a" NoClass (App (Var "139" "f") NotErased (Parens "141" (App (App (AppTp (Var "142" "n") (TpVar "146" "X")) NotErased (Var "148" "f")) NotErased (Var "150" "a")) "152"))))))) **"154"**)
     CmdsStart)))
    "155"
```

Haskell's parser:

```
File "0" ImportsStart "Cnat" ParamsNil
     (CmdsNext (DefTermOrType (DefType "13" "cNat" (Star "20") (Abs "24" All "26" "X" (Tkk (Star "30")) (TpArrow (TpParens "34" (TpArrow (TpVar "35" "X") UnerasedArrow (TpVar "39" "X")) "40") UnerasedArrow (TpArrow (TpVar "44" "X") UnerasedArrow (TpVar "48" "X"))))) **"50"**)
     (CmdsNext (DefTermOrType (DefTerm "52" "cZ" (Type (TpVar "57" "cNat")) (Lam "64" ErasedLambda "66" "X" NoClass (Lam "70" KeptLambda "72" "f" NoClass (Lam "76" KeptLambda "78" "a" NoClass (Var "82" "a"))))) **"84"**)
     (CmdsNext (DefTermOrType (DefTerm "86" "cS" (Type (TpArrow (TpVar "91" "cNat") UnerasedArrow (TpVar "98" "cNat"))) (Lam "105" KeptLambda "107" "n" NoClass (Lam "111" ErasedLambda "113" "X" NoClass (Lam "117" KeptLambda "119" "f" NoClass (Lam "123" KeptLambda "125" "a" NoClass (App (Var "129" "f") NotErased (Parens "131" (App (App (AppTp (Var "132" "n") (TpVar "136" "X")) NotErased (Var "138" "f")) NotErased (Var "140" "a")) "141"))))))) **"143"**)
     CmdsStart)))
     "145"
```

* Some associations grammar disambiguation in terms application and arrow operator in kinds.

For example the following term production rules:

```
aterm -> aterm ws maybeErased aterm .

maybeErased -> .
maybeErased -> '-' ows 
```
are replaced by:

```
Aterm ->  Aterm     Lterm
Aterm ->  Aterm '-' Lterm
```

So terms applications explicitly associates from left to right. Notation: names of grammar variables begin with uppercase, while tokens begin with lowercase or are quoted. Another change implied by the last rule, is that the left `aterm` and the `'-'` symbols could produce strings without any white spaces between the strings generated by them (equivalent to a rule `aterm -> aterm` **ows** `maybeErased aterm`)

Another example of associations disambiguation, now in kinds, is the following:

```
kind -> kind ows '➔' ows kind
```

is replaced by:

```
Kind -> LKind '➔' Kind
```

So arrow symbol associates explicitly from right to left.

Theses operators precedences could also be reproduced by the use of Happy Context-Dependent Operator Precedence mechanism, but to keep the grammar more similar to the original one this mechanism is not applied.
   
* Because of a **reduce/reduce conflict** with variables and holes in types and terms I added brackets to terms equality type syntax. That is, the following rule:

```
Type -> Term '≃' Term
```

is replaced by:

```
Type -> '{' Term '≃' Term '}'
```

* Verification of the generated AST against Agda's original parser.

* There exist three **shift/reduce conflicts**. Two of them are problematic, and are related with the LiftingType rules (specifically with `LiftingType -> Type '➔' LiftingType` rule). Next is detailed a problematic example. First I show the shift/reduce conflict in the state 12 of the generated parser (extracted from file [src/CedilleParser.info](src/CedilleParser.info)).

```
State 12

        ...
	Type -> LType . '➔' Type                           (rule 74)
	Type -> LType .                                     (rule 75)
        ...
	
	'➔'            shift, and enter state 116
			(reduce using rule 75)
```

The input `a ➔ ☆` can be generated by LiftingType rules, as shown in next figure.

![Derivation image](doc/conflicts/derivation.jpg)

But due to previous shift/reduce conflict it is not parsed. Next is the output of the parser run in debug mode for this input:

```
state: 6,	token: 1,	action: shift, enter state 17
state: 17,	token: 49,	action: reduce (rule 106), goto state 16
state: 16,	token: 49,	action: reduce (rule 83), goto state 13
state: 13,	token: 49,	action: reduce (rule 81), goto state 12
state: 12,	token: 49,	action: shift, enter state 116
state: 116,	token: 53,	action: fail.
state: 116,	token: 0,	action: fail.
```

In the state 12 the generated parser reads the arrow symbol as part of a Type (`Type -> LType . '➔' Type`) and not of a LiftingType rule (`LiftingType -> Type . '➔' LiftingType`, by first applying a reduce with `Type -> LType` rule, and then previous rule).

